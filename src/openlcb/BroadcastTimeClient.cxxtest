#include "utils/async_if_test_helper.hxx"

#include "openlcb/BroadcastTimeClient.hxx"

#include <inttypes.h>

#if 1
#define PRINT_ALL_PACKETS() print_all_packets()
#else
#define PRINT_ALL_PACKETS()
#endif

// test helper
::testing::AssertionResult IsBetweenInclusive(int val, int a, int b)
{
    if((val >= a) && (val <= b))
        return ::testing::AssertionSuccess();
    else
        return ::testing::AssertionFailure()
               << val << " is outside the range " << a << " to " << b;
}

namespace openlcb
{

class MockBroadcastTimeClient : public BroadcastTimeClient
{
public:
    MockBroadcastTimeClient(Node *node, NodeID clock_id,
                            bool configure_agent = false)
        : BroadcastTimeClient(node, clock_id, configure_agent)
        , time_(0)
        , mochRate_(1)
        , mochStarted_(false)
    {
        snprintf(clockIDString_, 13, "%012" PRIX64, clock_id);
    }

    void settime(int rate = 0, unsigned year = 0, unsigned month = 0,
                 unsigned day = 1, unsigned hour = 0, unsigned minute = 0)
    {
        mochRate_ = rate;
        tmMock_.tm_sec = 0;
        tmMock_.tm_min = minute;
        tmMock_.tm_hour = hour;
        tmMock_.tm_mday = day;
        tmMock_.tm_mon = month - 1;
        tmMock_.tm_year = year - 1900;
        tmMock_.tm_isdst = 0;
        time_ = ::mktime(&tmMock_);
    }

    void advance_time_minute()
    {
        time_ += mochRate_ >= 0 ? 60 : -60;
        ::gmtime_r(&time_, &tmMock_);
    }

    int getyear()
    {
        return tmMock_.tm_year + 1900;
    }

    int getmonth()
    {
        return tmMock_.tm_mon + 1;
    }

    int getday()
    {
        return tmMock_.tm_mday;
    }

    int gethour()
    {
        return tmMock_.tm_hour;
    }

    int getminute()
    {
        return tmMock_.tm_min;
    }

    time_t time_;
    struct tm tmMock_;
    int mochRate_;
    bool mochStarted_;
    char clockIDString_[13];
};


class BroadcastTimeClientTest : public AsyncNodeTest
{
protected:
    BroadcastTimeClientTest()
        : client1_(node_, BroadcastTimeDefs::DEFAULT_FAST_CLOCK_ID)
        , client2_(node_, BroadcastTimeDefs::DEFAULT_REALTIME_CLOCK_ID, true)
    {
    }

    // build up a packet to send
    void send_packet_helper(MockBroadcastTimeClient *client,
                            const char can_mti[4], const char suffix[5])
    {
        string payload(":X19");
        payload += can_mti;
        payload += "001N";
        payload += client->clockIDString_;
        payload += suffix;
        payload += ';';
        send_packet(payload.c_str());
    }
        
    // send start
    void send_start(MockBroadcastTimeClient *client, bool identify = false)
    {
        send_packet_helper(client, identify ? "544" : "5B4", "F002");
        client->mochStarted_ = true;
    }

    // send stop
    void send_stop(MockBroadcastTimeClient *client, bool identify = false)
    {
        send_packet_helper(client, identify ? "544" : "5B4", "F001");
        client->mochStarted_ = false;
    }

    // send report rate
    void send_report_rate(MockBroadcastTimeClient *client,
                          bool identify = false)
    {
        char srate[5];
        uint16_t rate12 = client->mochRate_ & 0xFFF;
        snprintf(srate, 5, "4%03x", rate12);
        send_packet_helper(client, identify ? "544" : "5B4", srate);
    }

    // send report year
    void send_report_year(MockBroadcastTimeClient *client,
                          bool identify = false)
    {
        char syear[5];
        snprintf(syear, 5, "3%03x", client->getyear());
        send_packet_helper(client, identify ? "544" : "5B4", syear);
    }

    // send report date
    void send_report_date(MockBroadcastTimeClient *client,
                          bool identify = false)
    {
        char sdate[5];
        snprintf(sdate, 5, "2%1x%02x", client->getmonth(), client->getday());
        send_packet_helper(client, identify ? "544" : "5B4", sdate);
    }

    // send report time
    void send_report_time(MockBroadcastTimeClient *client,
                          bool identify = false)
    {
        bool rollover = false;
        char stime[5];
        snprintf(stime, 5, "%02x%02x", client->gethour(), client->getminute());

        if (client->mochStarted_ && client->mochRate_ > 0 &&
            !identify && client->gethour() == 0 && client->getminute() == 0)
        {
            // rollover running forward
            rollover = true;
        }
        if (client->mochStarted_ && client->mochRate_ < 0 &&
            !identify && client->gethour() == 23 && client->getminute() == 59)
        {
            // rollover running backward
            rollover = true;
        }

        if (rollover)
        {
            send_packet_helper(client, "5B4", "F003");
        }
        send_packet_helper(client, identify ? "544" : "5B4", stime);
        if (rollover)
        {
            sleep(3);
            send_report_year(client);
            send_report_date(client);
        }
    }

    // send the synchronization sequence
    void sync(MockBroadcastTimeClient *client, unsigned delay_msec = 0)
    {
        client->mochStarted_ ? send_start(client, true) :
                               send_stop(client, true);
        send_report_rate(client, true);
        send_report_year(client, true);
        send_report_date(client, true);
        send_report_time(client, true);
        usleep(delay_msec * 1000);
        client->advance_time_minute();
        send_report_time(client);
    }

    MockBroadcastTimeClient client1_; // not a configure agent
    MockBroadcastTimeClient client2_; // configure agent
};

TEST_F(BroadcastTimeClientTest, Create)
{
    PRINT_ALL_PACKETS();

    // receive query
    expect_packet(":X195B422AN010100000100F000;");
    expect_packet(":X195B422AN010100000101F000;");
    wait_for_event_thread();

    // expect consumer identify range and producder idenfied query (unknown)
    expect_packet(":X194A422AN010100000100FFFF;");
    expect_packet(":X1954722AN010100000100F000;");

    // configure agent
    // expect consumer identify range and producer identify range
    expect_packet(":X194A422AN0101000001010000;");
    expect_packet(":X1952422AN0101000001018000;");

    send_packet(":X19970001N;");
    wait_for_event_thread();

    // time is not setup, clock is not running, expect 0 as default
    EXPECT_EQ(client1_.time(), 0);
    EXPECT_EQ(client1_.day_of_week(), BroadcastTimeDefs::THURSDAY);
    EXPECT_EQ(client1_.day_of_year(), 0);
    EXPECT_EQ(client2_.time(), 0);
    EXPECT_EQ(client2_.day_of_week(), BroadcastTimeDefs::THURSDAY);
    EXPECT_EQ(client2_.day_of_year(), 0);
};

TEST_F(BroadcastTimeClientTest, Start)
{
    print_all_packets();

    // receive query
    expect_packet(":X195B422AN010100000100F000;");
    expect_packet(":X195B422AN010100000101F000;");
    wait_for_event_thread();

    // start the clock, synchronize the client
    send_start(&client1_);
    client1_.settime(4, 1970, 1, 1, 0, 0);
    sync(&client1_, 500);
    usleep(200000);
    
    
    // check the time, we give it a finite range just in case of some OS jitter
    EXPECT_TRUE(IsBetweenInclusive(client1_.time(), 60, 62));
    EXPECT_EQ(client1_.day_of_week(), BroadcastTimeDefs::THURSDAY);
    EXPECT_EQ(client1_.day_of_year(), 0);
};

TEST_F(BroadcastTimeClientTest, DateRolloverForward)
{
    PRINT_ALL_PACKETS();

    // receive query
    expect_packet(":X195B422AN010100000100F000;");
    expect_packet(":X195B422AN010100000101F000;");
    wait_for_event_thread();

    // start the clock, synchronize the client
    send_start(&client1_);
    client1_.settime(4, 1970, 1, 1, 23, 59);
    sync(&client1_, 500);
    usleep(200000);
    
    
    // check the time, we give it a finite range just in case of some OS jitter
    EXPECT_TRUE(IsBetweenInclusive(client1_.time(), 86402, 86404));
    EXPECT_EQ(client1_.day_of_week(), BroadcastTimeDefs::FRIDAY);
    EXPECT_EQ(client1_.day_of_year(), 1);
};

TEST_F(BroadcastTimeClientTest, DateRolloverBackward)
{
    PRINT_ALL_PACKETS();

    // receive query
    expect_packet(":X195B422AN010100000100F000;");
    expect_packet(":X195B422AN010100000101F000;");
    wait_for_event_thread();

    // start the clock, synchronize the client
    send_start(&client1_);
    client1_.settime(-4, 1970, 1, 2, 0, 0);
    sync(&client1_, 500);
    usleep(200000);
    
    
    // check the time, we give it a finite range just in case of some OS jitter
    EXPECT_TRUE(IsBetweenInclusive(client1_.time(), 86336, 86338));
    EXPECT_EQ(client1_.day_of_week(), BroadcastTimeDefs::THURSDAY);
    EXPECT_EQ(client1_.day_of_year(), 0);
};

TEST_F(BroadcastTimeClientTest, ProgressionForwardFast)
{
    print_all_packets();

    // receive query
    expect_packet(":X195B422AN010100000100F000;");
    expect_packet(":X195B422AN010100000101F000;");
    wait_for_event_thread();

    // start the clock, synchronize the client
    send_start(&client1_);
    // rate = 500 (500 * 4 = 2000)
    client1_.settime(500 * 4, 1970, 1, 1, 0, 0);
    // after sync, time should be Jan 1, 1970 00:01:00
    sync(&client1_, 500);

    // wait 960 fast seconds (16 minutes).
    // 960 / 500 = 1.92 fast seconds
    usleep(1920000);


    // check the time, we give it a finite range just in case of some OS jitter
    EXPECT_TRUE(IsBetweenInclusive(client1_.time(), 1020, 1021));
    EXPECT_EQ(client1_.day_of_week(), BroadcastTimeDefs::THURSDAY);
    EXPECT_EQ(client1_.day_of_year(), 0);
};

TEST_F(BroadcastTimeClientTest, ProgressionReverseFast)
{
    print_all_packets();

    // receive query
    expect_packet(":X195B422AN010100000100F000;");
    expect_packet(":X195B422AN010100000101F000;");
    wait_for_event_thread();

    // start the clock, synchronize the client
    send_start(&client1_);
    // rate = -500 (-500 * 4 = -2000)
    client1_.settime(-500 * 4, 1970, 1, 1, 0, 20);
    // after sync, time should be Jan 1, 1970 00:19:00
    sync(&client1_, 500);

    // wait 960 fast seconds (16 minutes).
    // 960 / 500 = 1.92 fast seconds
    usleep(1920000);


    // check the time, we give it a finite range just in case of some OS jitter
    EXPECT_TRUE(IsBetweenInclusive(client1_.time(), 179, 181));
    EXPECT_EQ(client1_.day_of_week(), BroadcastTimeDefs::THURSDAY);
    EXPECT_EQ(client1_.day_of_year(), 0);
};


} // namespace openlcb
