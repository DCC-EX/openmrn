#include "utils/DirectHub.hxx"

#include "utils/test_main.hxx"

DataBufferPool pool_64(64);

class DirectHubTest : public ::testing::Test
{
protected:
    /// Creates two hub ports via socketpair and registers them to the data
    /// hub. Saves the other endpoints to fdOne_ and fdTwo_.
    void create_two_ports()
    {
        int fd[2];
        ERRNOCHECK("socketpair", socketpair(AF_UNIX, SOCK_STREAM, 0, fd));

        int buflen = 1700;
        socklen_t optlen = sizeof(buflen);
        ERRNOCHECK("setsockopt",
            setsockopt(fd[0], SOL_SOCKET, SO_SNDBUF, &buflen, optlen));
        ERRNOCHECK("setsockopt",
            setsockopt(fd[1], SOL_SOCKET, SO_SNDBUF, &buflen, optlen));

        int ffd[2];
        ERRNOCHECK("socketpair", socketpair(AF_UNIX, SOCK_STREAM, 0, ffd));
        ERRNOCHECK("setsockopt",
            setsockopt(ffd[0], SOL_SOCKET, SO_SNDBUF, &buflen, optlen));
        ERRNOCHECK("setsockopt",
            setsockopt(ffd[1], SOL_SOCKET, SO_SNDBUF, &buflen, optlen));
        create_port_for_fd(hub_, fd[0]);
        create_port_for_fd(hub_, ffd[0]);
        fdOne_ = fd[1];
        fdTwo_ = ffd[1];
        wait_for_main_executor();
    }

    DirectHubTest() {
#if OPENMRN_FEATURE_BSD_SOCKETS_IGNORE_SIGPIPE
        // We expect write failures to occur but we want to handle them where
        // the error occurs rather than in a SIGPIPE handler.
        signal(SIGPIPE, SIG_IGN);
#endif // OPENMRN_FEATURE_BSD_SOCKETS_IGNORE_SIGPIPE
    }
    
    ~DirectHubTest() {
        if (fdOne_ >= 0) {
            ::close(fdOne_);
            fdOne_ = -1;
        }
        if (fdTwo_ >= 0) {
            ::close(fdTwo_);
            fdTwo_ = -1;
        }
        wait_for_main_executor();
    }

    /// Reads whatever data is available on fd (up to 1000 bytes) and returns
    /// it as a string.
    /// @param fd a readable file descriptor
    /// @return data read.
    string read_some(int fd)
    {
        char buf[1000];
        int ret = ::read(fd, buf, sizeof(buf));
        HASSERT(ret >= 0);
        return string(buf, ret);
    }

    ssize_t write_some(int fd) {
        char inbuf[900];
        memset(inbuf, 0x55, sizeof(inbuf));
        return ::write(fd, inbuf, sizeof(inbuf));
    }

    DirectHubInterface<uint8_t[]> *hub_ {create_hub(&g_executor)};

    int fdOne_ = -1;
    int fdTwo_ = -1;
};

TEST_F(DirectHubTest, end_to_end_data)
{
    create_two_ports();

    ASSERT_EQ(6, ::write(fdOne_, "abcdef", 6));
    usleep(10000);

    EXPECT_EQ("abcdef", read_some(fdTwo_));

    ASSERT_EQ(1, ::write(fdOne_, "x", 1));
    usleep(10000);
    ASSERT_EQ(1, ::write(fdOne_, "y", 1));
    usleep(10000);
    ASSERT_EQ(1, ::write(fdOne_, "z", 1));
    usleep(10000);
    ASSERT_EQ(1, ::write(fdOne_, "w", 1));
    usleep(10000);

    EXPECT_EQ("xyzw", read_some(fdTwo_));
}

TEST_F(DirectHubTest, notifies_messages_empty)
{
    BarrierNotifiable bn1(EmptyNotifiable::DefaultInstance());
    BarrierNotifiable bn2(EmptyNotifiable::DefaultInstance());
    DataBuffer *buf;
    pool_64.alloc(&buf);
    EXPECT_EQ(1u, buf->references());
    buf->set_done(&bn1);
    bool complete = false;
    hub_->enqueue_send(new CallbackExecutable([this, buf, &bn2, &complete]() {
        hub_->mutable_message()->done_ = &bn2;
        hub_->mutable_message()->payload_ = buf;
        hub_->mutable_message()->skip_ = 0;
        hub_->mutable_message()->size_ = 10;
        hub_->do_send();
        complete = true;
    }));
    EXPECT_TRUE(complete);
    EXPECT_TRUE(bn1.is_done());
    EXPECT_TRUE(bn2.is_done());
    EXPECT_EQ(0u, buf->references());
}

TEST_F(DirectHubTest, large_end_to_end_data)
{
    create_two_ports();

    size_t bytes = 0;
    for (int i = 0; i < 100; i++) {
        write_some(fdOne_);
        usleep(1000);
        bytes += read_some(fdTwo_).size();
    }
    LOG(INFO, "total bytes transferred: %zu", bytes);
}

TEST_F(DirectHubTest, close_notify)
{
    int fd[2];
    int ffd[2];
    ERRNOCHECK("socketpair", socketpair(AF_UNIX, SOCK_STREAM, 0, fd));
    ERRNOCHECK("socketpair", socketpair(AF_UNIX, SOCK_STREAM, 0, ffd));
    LOG(INFO, "socket %d %d", fd[0], fd[1]);
    SyncNotifiable n;
    create_port_for_fd(hub_, fd[0], &n);
    create_port_for_fd(hub_, ffd[0]);
    write_some(fd[1]);

    read_some(ffd[1]);
    ::close(fd[1]);
    write_some(ffd[1]);
    usleep(10000);
    n.wait_for_notification();

    ::close(ffd[1]);
}

TEST_F(DirectHubTest, socket_blocked)
{
    create_two_ports();

    int buflen;
    socklen_t optlen = sizeof(buflen);
    ERRNOCHECK("getsockopt",
        getsockopt(fdOne_, SOL_SOCKET, SO_SNDBUF, &buflen, &optlen));
    LOG(INFO, "snd buf %d", buflen);

    ERRNOCHECK("fcntl", ::fcntl(fdOne_, F_SETFL, O_RDWR | O_NONBLOCK));

    int wr = write_some(fdOne_);
    LOG(INFO, "%d", wr);
    wr = write_some(fdOne_);
    LOG(INFO, "%d", wr);
    wr = write_some(fdOne_);
    LOG(INFO, "%d", wr);
    wr = write_some(fdOne_);
    LOG(INFO, "%d", wr);
}
