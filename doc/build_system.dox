/**
@page build_system_page Build system

@tableofcontents

@section Overview

The key added value of the OpenMRN build system is that it allows compiling a
multitude of applications across vastly different hardware architectures from a
single set of source files. It allows selecting different toolchains (e.g. g++
or clang for linux, mingw for windows, armgcc for cortex-m3, emscripten-clang
for node.js), providing different compilation options and selecting different
set of source files to compile on each specific port. Applications can share
operating system support files, drivers, networking stack, system libraries, or
libraries defining application logic.

@section core_concepts Concepts

The OpenMRN build system is based upon recursive make. Each directory contains
a Makefile, and during the compilation process these makefiles instruct the
build program to recurse into the relevant subdirectories and execute `make`
there.

The most important concept is the *target*.
- It defines the toolchain and compiler settings to be used;
- defines which operating system the code shall be compiled for;
- sets all the compilation flags;
- defines the code that shall be compiled vs skipped.

Generally, all code in `openmrn/src` gets compiled once per *core target*, and
all code in the application tree gets compiled once per *application target*.

@subsection core_target Core target

A core target is represented by a directory under `openmrn/targets/`. There is
one core target for each operating system + processor combination, so you find
items here like `linux.x86` or `freertos.armv7m`, meaning a Cortex-M3/M4
microcontroller run under the FreeRTOS operating system.

Code that is part of the `openmrn/src` tree but is hardware-specific (usually
under the `freertos_drivers` subdirectory) is organized into separate
directories for each vendor and hardware model/line, so that the availability
of necessary dependencies can get checked and the hardware-specific compilation
flags, such as include paths can be generated.

The output of the compilation of a core target is a set of libraries and object
files that can be linked into an application for that specific OS and
processor.

@subsection application_target Application target

Application targets are found under `$(APP_ROOT)/targets` directory, for
example
https://github.com/bakerstu/openmrn/tree/master/applications/hub/targets.  Each
application target will turn into one binary. The above example shows that this
application has ports for linux on a PC, linux on a Raspberry Pi / BeagleBone,
and MacOS using x86 processor. A different example
https://github.com/bakerstu/openmrn/tree/master/applications/io_board/targets
shows that we have one such target directory for each different hardware board
(and sometimes HW revision) that the application supports; this allows
adjusting the compilation to different GPIO pinouts, and link in different
device drivers.

Each application target selects a core target from which to link, usually with
the code `TARGET := freertos.armv7m` inside the Makefile. If not specified,
then the application target name will be used as the core target, which works
fine for examples like linux.x86 or linux.armv7a.

@section directory_structure Directory structure

In the OpenMRN distribution we have the following structure:

- {@code applications} Ccontains a number of example applications. The
  application tree is described below.

- {@code bin} Scripts and tools not directly used by the build system.

- {@code boards} Hhardware-specific code that can be shared by different
  applications that run on the same board or MCU family, such as interrupt
  vector tables, hardware initialization routines and GPIO pinouts. The code
  that is committed here usually gets symlinked into the application target
  directory. Some examples:

  - {@code armv7m} General definitions for all Cortex-M3/M4 MCUs

  - {@code ti-cc3200-generic} Interrupt vector table, linker scripts and some
    utilities for the CC3200 series MCU from TI (Texas Instruments). These
    files will be used by all CC3200-based targets.

  - {@code ti-cc3200-launchpad} Pin definitions and hardware initialization
    code for the CC3200-LAUNCHXL launchpad. References files from the
    `ti-cc3200-generic` directory.

- {@code doc} The documentation using Doxygen, and the make scripts to
  generate it. Run `make docs` in this directory to generate the HTML output of
  the documentation.

- {@code etc} Makefile libraries that are used by the build system. The `*.mk`
  files here get included into the makefiles.

- {@code include} Header files that are global (not library-specific). There
  are very few of these, mostly for FreeRTOS and some used for patching broken
  libc and middleware distributions.

- {@code src} The source code of OpenMRN core libraries. These are:

  - {@code console} A telnet-like server that you can use to present a
    commandline console. It can operate via network socket or serial
    connection.

  - {@code dcc} Declarations and classes for implementing and representing DCC
    protocol; used by command stations, mobile decoders and RailCom detectors.

  - {@code executor} Core library for co-routine based collaborative
    multi-tasking. Allows time division multi-tasking on a single thread,
    including running a large number of state machines interacting with message
    queues to for protocol stacks.

  - {@code freertos_drivers} Posix-compatible hardware abstraction layer
    running on FreeRTOS, with driver implementations for a number of popular
    microcontrollers' common hardware (such as UART, USB, and CAN-bus drivers).

    - {@code common} Base classes for drivers and posix device abstraction.
    - {@code esp8266} Implementations for the Espressif ESP8266 MCU.
    - {@code net_cc32xx} Socket layer for the Texas Instruments CC32xx Wifi
MCUs.
    - {@code net_freertos_tcp} Socket layer using FreeRTOSPlus TCP.
    - {@code nxp} Drivers for the NXP LPC17xx/40xx and 11Cxx MCUs.
    - {@code pic32mx} Drivers for the Microchip PIC32 series, a MIPS4K based
MCU.

    - {@code st} Drivers for various stm32 MCUs, including F0, F1, F4 lines,
  which are low-cost Cortex-M0 / M3 / M4 based MCUs.

    - {@code ti} General drivers (CAN, UART, USB, GPIO) for Texas Instruments
      Tiva and CC32xx MCUs.

  - {@code openlcb} LCC / OpenLCB protocol stack. Most of this protocol stack
    is implemented using protocol state flows and can operate on
    single-threaded environments using the Executor framework.

  - {@code os} OS abstraction layer with common concepts cross Linux, Mac,
    FreeRTOS, and to some extent windows. The concepts include threads,
    mutexes, sempahores, timers, support for select, GPIOs, mDNS.

  - {@code utils} A large number of diverse utility classes for data
    structures, buffers & queues, logging, testing, printing and formatting
    data, creating and using streams and sockets. Helper classes for
    implementing data hubs / repeaters, including tying them to various device
    drivers such as CAN-bus or USB.

  - {@code withrottle} Implementation for JMRI's wireless throttle protocol.\

- {@code targets} All core targets. These are listed in importance order, not
alphabetically:

  - {@code cov} Target for compiling and running unit tests (on the host) and
    test coverage generation.

  - {@code linux.x86} Host target using 'g++' as the compiler. This can be used
    to compile for the host OS under linux. It also work on a Raspberry Pi.

  - {@code linux.llvm} Host target under linux using 'llvm-c++' as the
    compiler. This is only used occasionally due to the more advanced static
    verification features of LLVM.

  - {@code mach.x86 and mach.x86_64} Host target on a Mac using the Xcode
compiler.

  - {@code linux.armv7a} Cross-compilation target for compiling to the
    Raspberry Pi and Beaglebone single-board computers using a PC host.

  - {@code js.emscripten} Cross-compilation target for creating a javascript
    library using the empscripten++ compiler, an LLVM backend turning code into
    javascript.

  - {@code mingw.x86} Cross-compilation target for creating a windows output
    executable using the MinGW libraries on a linux host. Does not work very
    well due to some incompatibilities between Windows and POSIX file
    descriptors and socket API.

  The remaining targets are various forms of microcontrollers, all needing the
  specific cross-compilation toolchain:

  - {@code freertos.armv7m} Cortex-M3/M4 using FreeRTOS microkernel. The most
    often used target. A number of vendor-specific driver directories are
    included inside that are each compiled using the specific vendor middleware
    into `.o` or `.a` files to be linked into applications using the specific
    MCU family.

  - {@code freertos.armv6m} Cortex-M0/M0+ using FreeRTOS.

  - {@code freertos.armv4t} ARM7TDMI microcontrollers (e.g. NXP LPC2367) using
    FreeRTOS.

  - {@code freertos.mips4k} PIC32MX microcontrollers using FreeRTOS.

  - {@code nonos.xtensa-lx106.esp8266} The ESP8266 WiFi microcontroller using
    the "NonOS" SDK, i.e. in single threaded mode.

  - {@code bare.armv7m} Cortex-M3/M4 microcontrollers without a microkernel, in
    single-threaded mode. This target is used for implementing really thin
    applications without the OS abstraction layer, such as bootloaders.

  - {@code bare.pruv3} The realtime processor cores from the select TI Sitara
    processors. These are found on the BeagleBone Black for example.

  - {@code freertos.armv7m.mbed-1768} Deprecated, should be removed.

- {@code test} Specific independent applications that can be loaded to various
  targets and exercise certain aspects of the target, mostly for blackbox
  testing and load testing of device drivers. An example such application would
  be a "Serial loopback for USB" that can be loaded into a Tiva Launchpad,
  connected to a host to test the performance and correctness of the USB device
  driver. Usually equipped with a host-side testing script as well.

@subsection core_target_dir Core target

This is the directory structure under a core target, which we will demonstrate
using the `openmrn/targets/freertos.armv7m` target, which is the most complex.

The directories are listed in importance order, not alphabetically.

- {@code console
 dcc
 executor
 openlcb
 os
 utils
 withrottle}
These directories correspond to the core libraries. Each core library is
built inside the respective directory. In the git repository these directories
only contain the Makefile, and when building they will be filled with `*.o`
files respective to the compiled sources. The result of the core library
compilation is a single `.a` archive, for example `openlcb.a`. There are a
couple of deprecated (empty) core target directories which need to be deleted,
too, such as `cue`, `if`, `core`.

- {@code lib} Contains all the core library archive files. This is the place
  where the application targets will go look for the core libraries for
  linking.

- {@code cJSON, tinyxml2} These are dependent libraries that are redistributed
  with the OpenMRN code. They get compiled like a core library.

- {@code freertos} Compiles the FreeRTOS microkernel code. See the
  `freertos/sources` file to see a description of where the source will be
  looked for, and which files to compile.

- {@code freertos_drivers} Contains the build code for all harware-specific
  sources, and the compilation outputs (`*.o` and `*.a` files). Some of the
  sources are coming from the `src/freertos_drivers` tree, while in other
  places we are compiling vendor-supplied middleware using the OpenMRN build
  compiler and settings. None of these directories contain source files; only
  makefiles and `sources` files that describe where to find the sources and
  what c/c++ files to compile from there. Sometimes the `sources` file is in
  the specific targets subdirectory, sometimes in the equivalent
  `src/freertos_drivers` directory.

  This directory will also host the build files for the shared code from
  `src/freertos_drivers/common`. The files to compile as well as the list of
  subdirectories to recurse into are described in
  `src/freertos_drivers/sources`.

  - {@code cc3220} OpenMRN device drivers compiled for the CC3220 MCU.

  - {@code cc3220driverlib} TI middleware drivers for the CC3220 MCU.

  - {@code cc3220sdk} TI SimpleLink middleware for the CC3220 MCU network
    processor.

  - {@code cc32xx} OpenMRN device drivers compiled for the CC3200 MCU.

  - {@code cc32xxsdk} TI SimpleLink middleware for the CC3220 MCU network
    processor.

  - {@code drivers_lpc1768} OpenMRN device drivers using the mbed library
    abstraction..

  - {@code freertos_tcp} TCP stack provided by the FreeRTOSPlus project.

  - {@code lpc_chip_175x_6x} Vendor middleware drivers for the NXP LPC175x/176x
    microcontrollers.

  - {@code mbed_lpc1768} Compiles the mbed libraries as middleware for the
    LPC1768 target.

  - {@code net_cc3220} OpenMRN posix-compatible socket layer compiled for the
    CC3220 network MCU.

  - {@code net_cc32xx} OpenMRN posix-compatible socket layer compiled for the
    CC3200 network MCU.

  - {@code net_freertos_tcp} OpenMRN posix-compatible socket layer for the
    FreeRTOSPlus TCP stack.

  - {@code stm32cubef103xb} Vendor middleware forthe STM32F1 processors
    (specifically compiled for the STM32F103xB).

  - {@code stm32cubef303x_28x_58x_98x} Vendor middleware for a range of
    STM32F3 processors.

  - {@code tivaware} OpenMRN device drivers for the Texas Instruments ARM
    Cortem-M4 Tiva processors (Tm4C123x and Tm4C129x).

@subsection application_dir Applications

Some example application directories to look at are:

- https://github.com/bakerstu/openmrn/tree/master/applications/io_board
- https://github.com/bakerstu/openmrn/tree/master/applications/hub
- https://github.com/balazsracz/openmrn_cue/tree/master/cs , which is an example
of an externally shipped application.

@subsubsection app_dir_location Locating application and OpenMRN directory

An application directory can be located anywhere in the file system. The
compilation can be started inside the application's toplevel directory (will
compile all application targets and their corresponding OpenMRN core targets),
or inside a single application target directory (will compile only that target
and its corresponding OpenMRN core target). `make` will ensure to only execute
compilation steps whose input files have changed, so most of the times
compiling the respective OpenMRN core target is very quick as nothing has
changed. For sample applications that are shipped with OpenMRN in the
`openmrn/applications` tree, a compilation started at the openmrn root will
recurse and build all of these applications with all of their targets.

In order to start a compilation inside an application or an application target
directory, it is essential that the build system can find the OpenMRN root
directory. This is ensured by setting the variable `OPENMRNPATH` to the
appropriate absolute directory path. Everything inside the OpenMRN tree will
then be referenced from this path, including makefile helper libraries, finding
the core targets and their compilation outputs, include path for `*.h` and
`*.hxx` files, etc... Usually at the beginning of the Makefile we set
OPENMRNPATH if it's not already set in the environment. For applications that
are shipped within the OpenMRN tree we just set `OPENMRNPATH=$(realpath ..)`
(it's important that this path be absolute and not relative since we'll refer
to it from different places), applications that are placed elsewhere in the
filesystem need to set OPENMRNPATH explicitly or in the user startup script
(e.g., in `~/.bashrc` writing `export OPENMRNPATH=~/openmrn`).

@subsubsection app_structure Application directory structure

From the toplevel application directory we have the following files and
subdirectories:



*/
