/**

@page concepts_overview Overview and Concepts

@tableofcontents

@section layering Layering Model

The OpenMRN software is broken down into distinct layers of.  The lowest
layer is acutely aware of the physical medium and the individual frames of
data that pass over it.  As one moves up in the layers, the constructs
become more abstract and more object oriented.

@dot
graph layer_model
{
    a [shape=box label = "User API"];
    n [shape=record,label="{{<e> Event | <d> Datagram | <s> Stream} | <n> Node}"];
    i [shape=box label = "Network"];
    g [shape=box label = "CAN Network"];
    h [shape=box label = "IP Network\n(Ethernet, WiFi, 6LoWPAN, ...)"];
    
    a -- n:e;
    a -- n:d;
    a -- n:s;
    n:n -- i;
    i -- g [style=dotted];
    i -- h [style=dotted];
}
@enddot

@section threading Threading Model
An OpenMRN application always contains a minimum of one thread
of execution managed by an operating system.  In the case of FreeRTOS, an
OpenMRN application will also contain an @ref idle_thread and a
@ref timer_thread.  OpenMRN is designed to support
a number of different operating systems, and a thin abstraction is provided
in order to hide any OS specific differences.  The OS abstraction is
provided by @ref OS.hxx, and applications are encouraged to make use of the
classes in @ref OS.hxx when accessing OS features such as threads, mutexes,
semaphores, etc...

@subsection main_thread Main Thread
The main thread is the thread of execution that os_main() is called with,
os_main() being the entry point of an application.
This thread is used for the application to initialize the stack.  Typically,
once any onetime initialization is complete, the OpenLCB stack inherits the
main thread for its own use with a SimpleCanStack::loop_executor() call.
 
@subsection timer_thread Timer Thread
FreeRTOS internally creates a thread for handling timers and events.  This
thread is managed by the RTOS and used by the RTOS.  It is not available for
application use.

@subsection idle_thread Idle Thread
Some of the OS ports, such as FreeRTOS utilize an idle thread hook.  This
hook is used as a diagnostic tool to check the high water mark or each
thread's stack.  This can aid the developer in choosing the right stack size
for each thread as to not overflow their stack and minimize total RAM usage.

@subsection additional_threads Additional Threads
An application may instantiate additional threads of its own using the
threading API found in OS.hxx.

@subsection executor_service_stateflow Executors, Services, State Flows and Dispatch Flows
OpenMRN contains a further abstraction of the threading model, which is used
by the OpenLCB stack.  It is also available for application use and is
described on the @ref executor_service_stateflow_page page.

@section hub_router_gateway Hubs, Routers, and Gateways
OpenMRN is designed to implement Hubs, Routers, and Gateways that can be
used to logically connect separate physical communications interfaces.  More
details can be found on the @ref hub_router_gateway_page page.

*/