/**

@page applications Sample Applications

@tableofcontents

@section application_introduction Introduction

The easiest way to get started for many people is with samples. We've provided
the source for some applications. Some of these applications you can run
directly from the command line. While others will require a device.

@section application_folders Directory Organization

The sample applications typically have the following folder structure:

    targets/
    config.mk
    Makefile
    subdirs

The code for an application typcially consists of two parts: shared and
target-specific. The shared code will be at the top folder for the application.
While the target-specific information will be under a target folder. As an
example, the blink_raw application has shared code here:

    applications/blink_raw/
        main.cxx
        targets/freertos.armv7m.mbed-1768/
            hw_init.cxx

The idea is that you can have target-specific (platform-specific) code that
allows customizing the shared code for different platforms.

@subsection application_build Building a Sample

Generally when you build a sample, you'll want to do so from a single target
directory, as that will build faster and only build what you need. Here we're
going to build the Linux versions so you can run them without needing a
specific board.

@section grid_connect GridConnect Protocol

Some of the sample applications use a protocol referred to here as the
GridConnect protocol. This is an ASCII protocol that is used by USB-to-CAN
interfaces sold by [GridConnect](http://gridconnect.com/).

A normal CAN message has the following format:

:X <_Identifier_> <N> <_Data-0_><_Data-1_>...<_Data-7_>;

These messages are sent within a single network (such as a CAN network or over
TCP) as binary. But if you're using one of the GridConnect devices, their
I/O format is text. Here is an actual example:

    :X19545415N0502010202000000;

The ID is 19545415. LCC uses 29-bit CAN identifiers. The data bytes are encoded
as HEX.

You can also have messages that contains no extra data. For example:

    :X17050415N;

A couple of the sample applications output this format to the console in order
to display the traffic. But, again, the actual CAN/TCP messages will be
binary messages.

@section application_list Applications

This section contains a brief description of the sample applications to help you
get up to speed. They're listed in order in which you might want to tackle them
rather than alphabetical order.

@subsection hub_application Hub

The hub application will run from the command line and it's a great place to
start with working on an LCC application. You can send CAN packets to the hub
over TCP and it will display the packets, and also forward them to any others
programs listening on the same port. This application knows about CAN packets,
but nothing about LCC. It will forward all CAN packets, regardless of their
format.

In addition, you can connect this application to an actual USB-to-CAN interface
in order to have packets flow between the LCC bus and programs running on your
desktop computer.

As mentioned above in the @ref application_folders section, you should typically
build samples from within a platform-specific folder. For example:

    cd ~/openmrn/applications/hub/targets/linux.x86
    make
    ./hub -h

This will build the application, and then show you the options for the hub
application. You can run the hub application without any parameters to start
capturing and displaying CAN traffic over TCP. The next application,
async_blink, will send out such traffic.

@subsection async_blink_application Async Blink

This is a more involved application, and is a good place to start with LCC. This
application can be run from the command line, or it can be hosted on a
micro controller to act as a very simple node.

This node sends out a "blink" event every second.

The Node ID is defined at the target level rather than the shared level. For
example, if you look at the linux.x86 target folder, you'll find the following
in the **NodeId.cxx** file:

*   extern const openlcb::NodeID NODE_ID;
*   const openlcb::NodeID NODE_ID = 0x050101011410ULL;

* **Note:** Node IDs are required to be unique, so you must obtain your own ID
before you ship anything using code you built with OpenMRN.

@section application_with_jmri Using JMRI's OpenLCB support

The two samples above both work on Linux using TCP traffic on port 12021. This
is the same port that JMRI can use, which means you can use JMRI to interact
with both the sample applications, and applications you write. In other words,
you can start writing and testing the LCC aspects of your application without
and actual device.

Why is this useful? In general, desktop develop is faster than embedded
development, as you're delaing with software that is running locally on a much
faster machine. As mentioned in @ref application_folders, you can easily create
two versions of an application that share a certain amount of code. So that
means you can share your LCC code between a desktop application and an embedded
application.

@subsection jmri_adding_openlcb Adding OpenLCB

In order to beging using JMRI with OpenLCB, assuming you have it installed,
you'll need to add an OpenLCB connection to JMRI, following these steps:

- Open the **Edit** menu and click **Preferences**.
- Under **Connections** click the + tab to the right of your existing connection
- Select **OpenLCB** under **System manufacturer**
- Under **System connection**, select **CAN Simulation** to use the TCB simulator
- Click **Save** and restart JMRI

@subsection jmri_hub OpenLCB Hub and Traffic Monitor

Once you've added an OpenLCB connection to JMRI, an **OpenLCB** menu will
appear after you restart JMRI. One option on this menu is to start a hub. This
hub acts very much like the hub application described above.

JMRI also has a traffic montior, which knows about the LCC protocol and
therefore will provide you more information about LCC packets.

You can learm more here: [Hardware Support: OpenLCB](http://jmri.sourceforge.net/help/en/html/hardware/openlcb/index.shtml)

Now try running @ref async_blink_application. You'll see some high-level traffic.
You can also open the **Configure Nodes** tool in JMRI. This won't show much
information for the @ref async_blink_application because it doesn't contain
any configuration information.

*/